<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/nodeca/pako"

    >pako (v1.0.5)</a>
</h1>
<h4>zlib port to javascript - fast, modularized, with browser support</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.pako">module pako</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.Deflate">
            function <span class="apidocSignatureSpan">pako.</span>Deflate
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.Inflate">
            function <span class="apidocSignatureSpan">pako.</span>Inflate
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.deflate">
            function <span class="apidocSignatureSpan">pako.</span>deflate
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.deflateRaw">
            function <span class="apidocSignatureSpan">pako.</span>deflateRaw
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.gzip">
            function <span class="apidocSignatureSpan">pako.</span>gzip
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.inflate">
            function <span class="apidocSignatureSpan">pako.</span>inflate
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.inflateRaw">
            function <span class="apidocSignatureSpan">pako.</span>inflateRaw
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.ungzip">
            function <span class="apidocSignatureSpan">pako.</span>ungzip
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_BEST_COMPRESSION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_BEST_SPEED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_BINARY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_BLOCK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_BUF_ERROR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_DATA_ERROR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_DEFAULT_COMPRESSION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_DEFAULT_STRATEGY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_DEFLATED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_ERRNO</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_FILTERED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_FINISH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_FIXED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_FULL_FLUSH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_HUFFMAN_ONLY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_NEED_DICT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_NO_COMPRESSION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_NO_FLUSH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_OK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_PARTIAL_FLUSH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_RLE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_STREAM_END</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_STREAM_ERROR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_SYNC_FLUSH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_TEXT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_TREES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pako.</span>Z_UNKNOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pako.</span>Deflate.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pako.</span>Inflate.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pako.</span>common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pako.</span>strings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pako.</span>trees</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pako.Deflate">module pako.Deflate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.Deflate.Deflate">
            function <span class="apidocSignatureSpan">pako.</span>Deflate
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pako.Deflate.prototype">module pako.Deflate.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.Deflate.prototype.onData">
            function <span class="apidocSignatureSpan">pako.Deflate.prototype.</span>onData
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.Deflate.prototype.onEnd">
            function <span class="apidocSignatureSpan">pako.Deflate.prototype.</span>onEnd
            <span class="apidocSignatureSpan">(status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.Deflate.prototype.push">
            function <span class="apidocSignatureSpan">pako.Deflate.prototype.</span>push
            <span class="apidocSignatureSpan">(data, mode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pako.Inflate">module pako.Inflate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.Inflate.Inflate">
            function <span class="apidocSignatureSpan">pako.</span>Inflate
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pako.Inflate.prototype">module pako.Inflate.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.Inflate.prototype.onData">
            function <span class="apidocSignatureSpan">pako.Inflate.prototype.</span>onData
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.Inflate.prototype.onEnd">
            function <span class="apidocSignatureSpan">pako.Inflate.prototype.</span>onEnd
            <span class="apidocSignatureSpan">(status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.Inflate.prototype.push">
            function <span class="apidocSignatureSpan">pako.Inflate.prototype.</span>push
            <span class="apidocSignatureSpan">(data, mode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pako.common">module pako.common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.common.Buf16">
            function <span class="apidocSignatureSpan">pako.common.</span>Buf16
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.common.Buf32">
            function <span class="apidocSignatureSpan">pako.common.</span>Buf32
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.common.Buf8">
            function <span class="apidocSignatureSpan">pako.common.</span>Buf8
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.common.arraySet">
            function <span class="apidocSignatureSpan">pako.common.</span>arraySet
            <span class="apidocSignatureSpan">(dest, src, src_offs, len, dest_offs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.common.assign">
            function <span class="apidocSignatureSpan">pako.common.</span>assign
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.common.flattenChunks">
            function <span class="apidocSignatureSpan">pako.common.</span>flattenChunks
            <span class="apidocSignatureSpan">(chunks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.common.setTyped">
            function <span class="apidocSignatureSpan">pako.common.</span>setTyped
            <span class="apidocSignatureSpan">(on)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.common.shrinkBuf">
            function <span class="apidocSignatureSpan">pako.common.</span>shrinkBuf
            <span class="apidocSignatureSpan">(buf, size)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pako.deflate">module pako.deflate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.deflate.deflate">
            function <span class="apidocSignatureSpan">pako.</span>deflate
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.deflate.Deflate">
            function <span class="apidocSignatureSpan">pako.deflate.</span>Deflate
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.deflate.deflateRaw">
            function <span class="apidocSignatureSpan">pako.deflate.</span>deflateRaw
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.deflate.gzip">
            function <span class="apidocSignatureSpan">pako.deflate.</span>gzip
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pako.inflate">module pako.inflate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.inflate.inflate">
            function <span class="apidocSignatureSpan">pako.</span>inflate
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.inflate.Inflate">
            function <span class="apidocSignatureSpan">pako.inflate.</span>Inflate
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.inflate.inflateRaw">
            function <span class="apidocSignatureSpan">pako.inflate.</span>inflateRaw
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.inflate.ungzip">
            function <span class="apidocSignatureSpan">pako.inflate.</span>ungzip
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pako.strings">module pako.strings</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.strings.binstring2buf">
            function <span class="apidocSignatureSpan">pako.strings.</span>binstring2buf
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.strings.buf2binstring">
            function <span class="apidocSignatureSpan">pako.strings.</span>buf2binstring
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.strings.buf2string">
            function <span class="apidocSignatureSpan">pako.strings.</span>buf2string
            <span class="apidocSignatureSpan">(buf, max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.strings.string2buf">
            function <span class="apidocSignatureSpan">pako.strings.</span>string2buf
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.strings.utf8border">
            function <span class="apidocSignatureSpan">pako.strings.</span>utf8border
            <span class="apidocSignatureSpan">(buf, max)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pako.trees">module pako.trees</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.trees._tr_align">
            function <span class="apidocSignatureSpan">pako.trees.</span>_tr_align
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.trees._tr_flush_block">
            function <span class="apidocSignatureSpan">pako.trees.</span>_tr_flush_block
            <span class="apidocSignatureSpan">(s, buf, stored_len, last)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.trees._tr_init">
            function <span class="apidocSignatureSpan">pako.trees.</span>_tr_init
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.trees._tr_stored_block">
            function <span class="apidocSignatureSpan">pako.trees.</span>_tr_stored_block
            <span class="apidocSignatureSpan">(s, buf, stored_len, last)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pako.trees._tr_tally">
            function <span class="apidocSignatureSpan">pako.trees.</span>_tr_tally
            <span class="apidocSignatureSpan">(s, dist, lc)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pako" id="apidoc.module.pako">module pako</a></h1>


    <h2>
        <a href="#apidoc.element.pako.Deflate" id="apidoc.element.pako.Deflate">
        function <span class="apidocSignatureSpan">pako.</span>Deflate
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: &#x27;&#x27;
  }, options || {});

  var opt = this.options;

  if (opt.raw &#x26;&#x26; (opt.windowBits &#x3e; 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip &#x26;&#x26; (opt.windowBits &#x3e; 0) &#x26;&#x26; (opt.windowBits &#x3c; 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = &#x27;&#x27;;     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === &#x27;string&#x27;) {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === &#x27;[object ArrayBuffer]&#x27;) {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* ##### Example:
*
* ```javascript
* var pako = require(&#x27;pako&#x27;)
*   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
*   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
*
* var deflate = new pako.<span class="apidocCodeKeywordSpan">Deflate</span>({ level: 3});
*
* deflate.push(chunk1, false);
* deflate.push(chunk2, true);  // true -&#x3e; last chunk
*
* if (deflate.err) { throw new Error(deflate.err); }
*
* console.log(deflate.result);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.Inflate" id="apidoc.element.pako.Inflate">
        function <span class="apidocSignatureSpan">pako.</span>Inflate
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: &#x27;&#x27;
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw &#x26;&#x26; (opt.windowBits &#x3e;= 0) &#x26;&#x26; (opt.windowBits &#x3c; 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits &#x3e;= 0) &#x26;&#x26; (opt.windowBits &#x3c; 16) &#x26;&#x26;
      !(options &#x26;&#x26; options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits &#x3e; 15) &#x26;&#x26; (opt.windowBits &#x3c; 48)) {
    // bit 3 (16) -&#x3e; gzipped data
    // bit 4 (32) -&#x3e; autodetect gzip/deflate
    if ((opt.windowBits &#x26; 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = &#x27;&#x27;;     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  console.log(err);
}

//
// Alternate interface for chunking &#x26; without exceptions
//

var inflator = new pako.<span class="apidocCodeKeywordSpan">Inflate</span>();

inflator.push(chunk1, false);
inflator.push(chunk2, false);
...
inflator.push(chunkN, true); // true -&#x3e; last chunk

if (inflator.err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.deflate" id="apidoc.element.pako.deflate">
        function <span class="apidocSignatureSpan">pako.</span>deflate
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don&#x27;t cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var pako = require(&#x27;pako&#x27;);

// Deflate
//
var input = new Uint8Array();
//... fill input data here
var output = pako.<span class="apidocCodeKeywordSpan">deflate</span>(input);

// Inflate (simple wrapper can throw exception on broken stream)
//
var compressed = new Uint8Array();
//... fill data to uncompress here
try {
var result = pako.inflate(compressed);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.deflateRaw" id="apidoc.element.pako.deflateRaw">
        function <span class="apidocSignatureSpan">pako.</span>deflateRaw
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.gzip" id="apidoc.element.pako.gzip">
        function <span class="apidocSignatureSpan">pako.</span>gzip
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.inflate" id="apidoc.element.pako.inflate">
        function <span class="apidocSignatureSpan">pako.</span>inflate
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don&#x27;t cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var output = pako.deflate(input);

// Inflate (simple wrapper can throw exception on broken stream)
//
var compressed = new Uint8Array();
//... fill data to uncompress here
try {
  var result = pako.<span class="apidocCodeKeywordSpan">inflate</span>(compressed);
} catch (err) {
  console.log(err);
}

//
// Alternate interface for chunking &#x26; without exceptions
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.inflateRaw" id="apidoc.element.pako.inflateRaw">
        function <span class="apidocSignatureSpan">pako.</span>inflateRaw
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.ungzip" id="apidoc.element.pako.ungzip">
        function <span class="apidocSignatureSpan">pako.</span>ungzip
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don&#x27;t cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pako.Deflate" id="apidoc.module.pako.Deflate">module pako.Deflate</a></h1>


    <h2>
        <a href="#apidoc.element.pako.Deflate.Deflate" id="apidoc.element.pako.Deflate.Deflate">
        function <span class="apidocSignatureSpan">pako.</span>Deflate
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: &#x27;&#x27;
  }, options || {});

  var opt = this.options;

  if (opt.raw &#x26;&#x26; (opt.windowBits &#x3e; 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip &#x26;&#x26; (opt.windowBits &#x3e; 0) &#x26;&#x26; (opt.windowBits &#x3c; 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = &#x27;&#x27;;     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === &#x27;string&#x27;) {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === &#x27;[object ArrayBuffer]&#x27;) {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* ##### Example:
*
* ```javascript
* var pako = require(&#x27;pako&#x27;)
*   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
*   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
*
* var deflate = new pako.<span class="apidocCodeKeywordSpan">Deflate</span>({ level: 3});
*
* deflate.push(chunk1, false);
* deflate.push(chunk2, true);  // true -&#x3e; last chunk
*
* if (deflate.err) { throw new Error(deflate.err); }
*
* console.log(deflate.result);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pako.Deflate.prototype" id="apidoc.module.pako.Deflate.prototype">module pako.Deflate.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pako.Deflate.prototype.onData" id="apidoc.element.pako.Deflate.prototype.onData">
        function <span class="apidocSignatureSpan">pako.Deflate.prototype.</span>onData
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onData = function (chunk) {
  this.chunks.push(chunk);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (status !== Z_STREAM_END &#x26;&#x26; status !== Z_OK) {
    this.onEnd(status);
    this.ended = true;
    return false;
  }
  if (strm.avail_out === 0 || (strm.avail_in === 0 &#x26;&#x26; (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
    if (this.options.to === &#x27;string&#x27;) {
      this.<span class="apidocCodeKeywordSpan">onData</span>(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
    } else {
      this.onData(utils.shrinkBuf(strm.output, strm.next_out));
    }
  }
} while ((strm.avail_in &#x3e; 0 || strm.avail_out === 0) &#x26;&#x26; status !== Z_STREAM_END);

// Finalize on the last chunk.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.Deflate.prototype.onEnd" id="apidoc.element.pako.Deflate.prototype.onEnd">
        function <span class="apidocSignatureSpan">pako.Deflate.prototype.</span>onEnd
        <span class="apidocSignatureSpan">(status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === &#x27;string&#x27;) {
      this.result = this.chunks.join(&#x27;&#x27;);
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  strm.output = new utils.Buf8(chunkSize);
  strm.next_out = 0;
  strm.avail_out = chunkSize;
}
status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

if (status !== Z_STREAM_END &#x26;&#x26; status !== Z_OK) {
  this.<span class="apidocCodeKeywordSpan">onEnd</span>(status);
  this.ended = true;
  return false;
}
if (strm.avail_out === 0 || (strm.avail_in === 0 &#x26;&#x26; (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
  if (this.options.to === &#x27;string&#x27;) {
    this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.Deflate.prototype.push" id="apidoc.element.pako.Deflate.prototype.push">
        function <span class="apidocSignatureSpan">pako.Deflate.prototype.</span>push
        <span class="apidocSignatureSpan">(data, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === &#x27;string&#x27;) {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === &#x27;[object ArrayBuffer]&#x27;) {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);<span class="apidocCodeCommentSpan">    /* no bad return value */
</span>
    if (status !== Z_STREAM_END &#x26;&#x26; status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 &#x26;&#x26; (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === &#x27;string&#x27;) {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in &#x3e; 0 || strm.avail_out === 0) &#x26;&#x26; status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//
// Alternate interface for chunking &#x26; without exceptions
//

var inflator = new pako.Inflate();

inflator.<span class="apidocCodeKeywordSpan">push</span>(chunk1, false);
inflator.push(chunk2, false);
...
inflator.push(chunkN, true); // true -&#x3e; last chunk

if (inflator.err) {
  console.log(inflator.msg);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pako.Inflate" id="apidoc.module.pako.Inflate">module pako.Inflate</a></h1>


    <h2>
        <a href="#apidoc.element.pako.Inflate.Inflate" id="apidoc.element.pako.Inflate.Inflate">
        function <span class="apidocSignatureSpan">pako.</span>Inflate
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: &#x27;&#x27;
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw &#x26;&#x26; (opt.windowBits &#x3e;= 0) &#x26;&#x26; (opt.windowBits &#x3c; 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits &#x3e;= 0) &#x26;&#x26; (opt.windowBits &#x3c; 16) &#x26;&#x26;
      !(options &#x26;&#x26; options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits &#x3e; 15) &#x26;&#x26; (opt.windowBits &#x3c; 48)) {
    // bit 3 (16) -&#x3e; gzipped data
    // bit 4 (32) -&#x3e; autodetect gzip/deflate
    if ((opt.windowBits &#x26; 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = &#x27;&#x27;;     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  console.log(err);
}

//
// Alternate interface for chunking &#x26; without exceptions
//

var inflator = new pako.<span class="apidocCodeKeywordSpan">Inflate</span>();

inflator.push(chunk1, false);
inflator.push(chunk2, false);
...
inflator.push(chunkN, true); // true -&#x3e; last chunk

if (inflator.err) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pako.Inflate.prototype" id="apidoc.module.pako.Inflate.prototype">module pako.Inflate.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pako.Inflate.prototype.onData" id="apidoc.element.pako.Inflate.prototype.onData">
        function <span class="apidocSignatureSpan">pako.Inflate.prototype.</span>onData
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onData = function (chunk) {
  this.chunks.push(chunk);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (status !== Z_STREAM_END &#x26;&#x26; status !== Z_OK) {
    this.onEnd(status);
    this.ended = true;
    return false;
  }
  if (strm.avail_out === 0 || (strm.avail_in === 0 &#x26;&#x26; (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
    if (this.options.to === &#x27;string&#x27;) {
      this.<span class="apidocCodeKeywordSpan">onData</span>(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
    } else {
      this.onData(utils.shrinkBuf(strm.output, strm.next_out));
    }
  }
} while ((strm.avail_in &#x3e; 0 || strm.avail_out === 0) &#x26;&#x26; status !== Z_STREAM_END);

// Finalize on the last chunk.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.Inflate.prototype.onEnd" id="apidoc.element.pako.Inflate.prototype.onEnd">
        function <span class="apidocSignatureSpan">pako.Inflate.prototype.</span>onEnd
        <span class="apidocSignatureSpan">(status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === &#x27;string&#x27;) {
      // Glue &#x26; convert here, until we teach pako to send
      // utf8 alligned strings to onData
      this.result = this.chunks.join(&#x27;&#x27;);
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  strm.output = new utils.Buf8(chunkSize);
  strm.next_out = 0;
  strm.avail_out = chunkSize;
}
status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

if (status !== Z_STREAM_END &#x26;&#x26; status !== Z_OK) {
  this.<span class="apidocCodeKeywordSpan">onEnd</span>(status);
  this.ended = true;
  return false;
}
if (strm.avail_out === 0 || (strm.avail_in === 0 &#x26;&#x26; (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
  if (this.options.to === &#x27;string&#x27;) {
    this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.Inflate.prototype.push" id="apidoc.element.pako.Inflate.prototype.push">
        function <span class="apidocSignatureSpan">pako.Inflate.prototype.</span>push
        <span class="apidocSignatureSpan">(data, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === &#x27;string&#x27;) {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === &#x27;[object ArrayBuffer]&#x27;) {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);<span class="apidocCodeCommentSpan">    /* no bad return value */
</span>
    if (status === c.Z_NEED_DICT &#x26;&#x26; dictionary) {
      // Convert data if needed
      if (typeof dictionary === &#x27;string&#x27;) {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === &#x27;[object ArrayBuffer]&#x27;) {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR &#x26;&#x26; allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END &#x26;&#x26; status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 &#x26;&#x26; (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH
))) {

        if (this.options.to === &#x27;string&#x27;) {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 &#x26;&#x26; strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in &#x3e; 0 || strm.avail_out === 0) &#x26;&#x26; status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//
// Alternate interface for chunking &#x26; without exceptions
//

var inflator = new pako.Inflate();

inflator.<span class="apidocCodeKeywordSpan">push</span>(chunk1, false);
inflator.push(chunk2, false);
...
inflator.push(chunkN, true); // true -&#x3e; last chunk

if (inflator.err) {
  console.log(inflator.msg);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pako.common" id="apidoc.module.pako.common">module pako.common</a></h1>


    <h2>
        <a href="#apidoc.element.pako.common.Buf16" id="apidoc.element.pako.common.Buf16">
        function <span class="apidocSignatureSpan">pako.common.</span>Buf16
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Uint16Array() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var low;               /* low bits for current root entry */
var mask;              /* mask for low root bits */
var next;             /* next available space in table */
var base = null;     /* base value table to use */
var base_index = 0;
//  var shoextra;    /* extra bits table to use */
var end;                    /* use base and extra for symbol &#x3e; end */
var count = new utils.<span class="apidocCodeKeywordSpan">Buf16</span>(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each
 length */
var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
var extra = null;
var extra_index = 0;

var here_bits, here_op, here_val;

/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.common.Buf32" id="apidoc.element.pako.common.Buf32">
        function <span class="apidocSignatureSpan">pako.common.</span>Buf32
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Int32Array() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.common.Buf8" id="apidoc.element.pako.common.Buf8">
        function <span class="apidocSignatureSpan">pako.common.</span>Buf8
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Uint8Array() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
if (strm.avail_out === 0) {
  strm.output = new utils.<span class="apidocCodeKeywordSpan">Buf8</span>(chunkSize);
  strm.next_out = 0;
  strm.avail_out = chunkSize;
}
status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

if (status !== Z_STREAM_END &#x26;&#x26; status !== Z_OK) {
  this.onEnd(status);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.common.arraySet" id="apidoc.element.pako.common.arraySet">
        function <span class="apidocSignatureSpan">pako.common.</span>arraySet
        <span class="apidocSignatureSpan">(dest, src, src_offs, len, dest_offs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arraySet = function (dest, src, src_offs, len, dest_offs) {
  if (src.subarray &#x26;&#x26; dest.subarray) {
    dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
    return;
  }
  // Fallback to ordinary array
  for (var i = 0; i &#x3c; len; i++) {
    dest[dest_offs + i] = src[src_offs + i];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    tail = strm.next_out - next_out_utf8;
    utf8str = strings.buf2string(strm.output, next_out_utf8);

    // move tail
    strm.next_out = tail;
    strm.avail_out = chunkSize - tail;
    if (tail) { utils.<span class="apidocCodeKeywordSpan">arraySet</span>(strm.output, strm.output, next_out_utf8, tail, 0); }

    this.onData(utf8str);

  } else {
    this.onData(utils.shrinkBuf(strm.output, strm.next_out));
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.common.assign" id="apidoc.element.pako.common.assign">
        function <span class="apidocSignatureSpan">pako.common.</span>assign
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assign = function (obj) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== &#x27;object&#x27;) {
      throw new TypeError(source + &#x27;must be non-object&#x27;);
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
if (!(this instanceof Deflate)) return new Deflate(options);

this.options = utils.<span class="apidocCodeKeywordSpan">assign</span>({
  level: Z_DEFAULT_COMPRESSION,
  method: Z_DEFLATED,
  chunkSize: 16384,
  windowBits: 15,
  memLevel: 8,
  strategy: Z_DEFAULT_STRATEGY,
  to: &#x27;&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.common.flattenChunks" id="apidoc.element.pako.common.flattenChunks">
        function <span class="apidocSignatureSpan">pako.common.</span>flattenChunks
        <span class="apidocSignatureSpan">(chunks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flattenChunks = function (chunks) {
  var i, l, len, pos, chunk, result;

  // calculate data length
  len = 0;
  for (i = 0, l = chunks.length; i &#x3c; l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  result = new Uint8Array(len);
  pos = 0;
  for (i = 0, l = chunks.length; i &#x3c; l; i++) {
    chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === &#x27;string&#x27;) {
      this.result = this.chunks.join(&#x27;&#x27;);
    } else {
      this.result = utils.<span class="apidocCodeKeywordSpan">flattenChunks</span>(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.common.setTyped" id="apidoc.element.pako.common.setTyped">
        function <span class="apidocSignatureSpan">pako.common.</span>setTyped
        <span class="apidocSignatureSpan">(on)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.<span class="apidocCodeKeywordSpan">setTyped</span>(TYPED_OK);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.common.shrinkBuf" id="apidoc.element.pako.common.shrinkBuf">
        function <span class="apidocSignatureSpan">pako.common.</span>shrinkBuf
        <span class="apidocSignatureSpan">(buf, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (status !== Z_STREAM_END &#x26;&#x26; status !== Z_OK) {
    this.onEnd(status);
    this.ended = true;
    return false;
  }
  if (strm.avail_out === 0 || (strm.avail_in === 0 &#x26;&#x26; (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
    if (this.options.to === &#x27;string&#x27;) {
      this.onData(strings.buf2binstring(utils.<span class="apidocCodeKeywordSpan">shrinkBuf</span>(strm.output, strm.next_out)));
    } else {
      this.onData(utils.shrinkBuf(strm.output, strm.next_out));
    }
  }
} while ((strm.avail_in &#x3e; 0 || strm.avail_out === 0) &#x26;&#x26; status !== Z_STREAM_END);

// Finalize on the last chunk.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pako.deflate" id="apidoc.module.pako.deflate">module pako.deflate</a></h1>


    <h2>
        <a href="#apidoc.element.pako.deflate.deflate" id="apidoc.element.pako.deflate.deflate">
        function <span class="apidocSignatureSpan">pako.</span>deflate
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don&#x27;t cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var pako = require(&#x27;pako&#x27;);

// Deflate
//
var input = new Uint8Array();
//... fill input data here
var output = pako.<span class="apidocCodeKeywordSpan">deflate</span>(input);

// Inflate (simple wrapper can throw exception on broken stream)
//
var compressed = new Uint8Array();
//... fill data to uncompress here
try {
var result = pako.inflate(compressed);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.deflate.Deflate" id="apidoc.element.pako.deflate.Deflate">
        function <span class="apidocSignatureSpan">pako.deflate.</span>Deflate
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: &#x27;&#x27;
  }, options || {});

  var opt = this.options;

  if (opt.raw &#x26;&#x26; (opt.windowBits &#x3e; 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip &#x26;&#x26; (opt.windowBits &#x3e; 0) &#x26;&#x26; (opt.windowBits &#x3c; 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = &#x27;&#x27;;     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === &#x27;string&#x27;) {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === &#x27;[object ArrayBuffer]&#x27;) {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* ##### Example:
*
* ```javascript
* var pako = require(&#x27;pako&#x27;)
*   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
*   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
*
* var deflate = new pako.<span class="apidocCodeKeywordSpan">Deflate</span>({ level: 3});
*
* deflate.push(chunk1, false);
* deflate.push(chunk2, true);  // true -&#x3e; last chunk
*
* if (deflate.err) { throw new Error(deflate.err); }
*
* console.log(deflate.result);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.deflate.deflateRaw" id="apidoc.element.pako.deflate.deflateRaw">
        function <span class="apidocSignatureSpan">pako.deflate.</span>deflateRaw
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.deflate.gzip" id="apidoc.element.pako.deflate.gzip">
        function <span class="apidocSignatureSpan">pako.deflate.</span>gzip
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pako.inflate" id="apidoc.module.pako.inflate">module pako.inflate</a></h1>


    <h2>
        <a href="#apidoc.element.pako.inflate.inflate" id="apidoc.element.pako.inflate.inflate">
        function <span class="apidocSignatureSpan">pako.</span>inflate
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don&#x27;t cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var output = pako.deflate(input);

// Inflate (simple wrapper can throw exception on broken stream)
//
var compressed = new Uint8Array();
//... fill data to uncompress here
try {
  var result = pako.<span class="apidocCodeKeywordSpan">inflate</span>(compressed);
} catch (err) {
  console.log(err);
}

//
// Alternate interface for chunking &#x26; without exceptions
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.inflate.Inflate" id="apidoc.element.pako.inflate.Inflate">
        function <span class="apidocSignatureSpan">pako.inflate.</span>Inflate
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: &#x27;&#x27;
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw &#x26;&#x26; (opt.windowBits &#x3e;= 0) &#x26;&#x26; (opt.windowBits &#x3c; 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits &#x3e;= 0) &#x26;&#x26; (opt.windowBits &#x3c; 16) &#x26;&#x26;
      !(options &#x26;&#x26; options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits &#x3e; 15) &#x26;&#x26; (opt.windowBits &#x3c; 48)) {
    // bit 3 (16) -&#x3e; gzipped data
    // bit 4 (32) -&#x3e; autodetect gzip/deflate
    if ((opt.windowBits &#x26; 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = &#x27;&#x27;;     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  console.log(err);
}

//
// Alternate interface for chunking &#x26; without exceptions
//

var inflator = new pako.<span class="apidocCodeKeywordSpan">Inflate</span>();

inflator.push(chunk1, false);
inflator.push(chunk2, false);
...
inflator.push(chunkN, true); // true -&#x3e; last chunk

if (inflator.err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.inflate.inflateRaw" id="apidoc.element.pako.inflate.inflateRaw">
        function <span class="apidocSignatureSpan">pako.inflate.</span>inflateRaw
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.inflate.ungzip" id="apidoc.element.pako.inflate.ungzip">
        function <span class="apidocSignatureSpan">pako.inflate.</span>ungzip
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don&#x27;t cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pako.strings" id="apidoc.module.pako.strings">module pako.strings</a></h1>


    <h2>
        <a href="#apidoc.element.pako.strings.binstring2buf" id="apidoc.element.pako.strings.binstring2buf">
        function <span class="apidocSignatureSpan">pako.strings.</span>binstring2buf
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i &#x3c; len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (this.ended) { return false; }
_mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

// Convert data if needed
if (typeof data === &#x27;string&#x27;) {
  // Only binary strings can be decompressed on practice
  strm.input = strings.<span class="apidocCodeKeywordSpan">binstring2buf</span>(data);
} else if (toString.call(data) === &#x27;[object ArrayBuffer]&#x27;) {
  strm.input = new Uint8Array(data);
} else {
  strm.input = data;
}

strm.next_in = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.strings.buf2binstring" id="apidoc.element.pako.strings.buf2binstring">
        function <span class="apidocSignatureSpan">pako.strings.</span>buf2binstring
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (status !== Z_STREAM_END &#x26;&#x26; status !== Z_OK) {
    this.onEnd(status);
    this.ended = true;
    return false;
  }
  if (strm.avail_out === 0 || (strm.avail_in === 0 &#x26;&#x26; (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
    if (this.options.to === &#x27;string&#x27;) {
      this.onData(strings.<span class="apidocCodeKeywordSpan">buf2binstring</span>(utils.shrinkBuf(strm.output, strm.next_out)));
    } else {
      this.onData(utils.shrinkBuf(strm.output, strm.next_out));
    }
  }
} while ((strm.avail_in &#x3e; 0 || strm.avail_out === 0) &#x26;&#x26; status !== Z_STREAM_END);

// Finalize on the last chunk.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.strings.buf2string" id="apidoc.element.pako.strings.buf2string">
        function <span class="apidocSignatureSpan">pako.strings.</span>buf2string
        <span class="apidocSignatureSpan">(buf, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i &#x3c; len;) {
    c = buf[i++];
    // quick process ascii
    if (c &#x3c; 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 &#x26; 6 byte codes
    if (c_len &#x3e; 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &#x26;= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len &#x3e; 1 &#x26;&#x26; i &#x3c; len) {
      c = (c &#x3c;&#x3c; 6) | (buf[i++] &#x26; 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len &#x3e; 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c &#x3c; 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c &#x3e;&#x3e; 10) &#x26; 0x3ff);
      utf16buf[out++] = 0xdc00 | (c &#x26; 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 &#x26;&#x26; (_mode === c.Z_FINISH || _mode ===
c.Z_SYNC_FLUSH))) {

        if (this.options.to === &#x27;string&#x27;) {

next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

tail = strm.next_out - next_out_utf8;
utf8str = strings.<span class="apidocCodeKeywordSpan">buf2string</span>(strm.output, next_out_utf8);

// move tail
strm.next_out = tail;
strm.avail_out = chunkSize - tail;
if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

this.onData(utf8str);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.strings.string2buf" id="apidoc.element.pako.strings.string2buf">
        function <span class="apidocSignatureSpan">pako.strings.</span>string2buf
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos &#x3c; str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c &#x26; 0xfc00) === 0xd800 &#x26;&#x26; (m_pos + 1 &#x3c; str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 &#x26; 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) &#x3c;&#x3c; 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c &#x3c; 0x80 ? 1 : c &#x3c; 0x800 ? 2 : c &#x3c; 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i &#x3c; buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c &#x26; 0xfc00) === 0xd800 &#x26;&#x26; (m_pos + 1 &#x3c; str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 &#x26; 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) &#x3c;&#x3c; 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c &#x3c; 0x80) {
<span class="apidocCodeCommentSpan">      /* one byte */
</span>      buf[i++] = c;
    } else if (c &#x3c; 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c &#x3e;&#x3e;&#x3e; 6);
      buf[i++] = 0x80 | (c &#x26; 0x3f);
    } else if (c &#x3c; 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c &#x3e;&#x3e;&#x3e; 12);
      buf[i++] = 0x80 | (c &#x3e;&#x3e;&#x3e; 6 &#x26; 0x3f);
      buf[i++] = 0x80 | (c &#x26; 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c &#x3e;&#x3e;&#x3e; 18);
      buf[i++] = 0x80 | (c &#x3e;&#x3e;&#x3e; 12 &#x26; 0x3f);
      buf[i++] = 0x80 | (c &#x3e;&#x3e;&#x3e; 6 &#x26; 0x3f);
      buf[i++] = 0x80 | (c &#x26; 0x3f);
    }
  }

  return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (opt.dictionary) {
var dict;
// Convert data if needed
if (typeof opt.dictionary === &#x27;string&#x27;) {
  // If we need to compress text, change encoding to utf8.
  dict = strings.<span class="apidocCodeKeywordSpan">string2buf</span>(opt.dictionary);
} else if (toString.call(opt.dictionary) === &#x27;[object ArrayBuffer]&#x27;) {
  dict = new Uint8Array(opt.dictionary);
} else {
  dict = opt.dictionary;
}

status = zlib_deflate.deflateSetDictionary(this.strm, dict);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.strings.utf8border" id="apidoc.element.pako.strings.utf8border">
        function <span class="apidocSignatureSpan">pako.strings.</span>utf8border
        <span class="apidocSignatureSpan">(buf, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max &#x3e; buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos &#x3e;= 0 &#x26;&#x26; (buf[pos] &#x26; 0xC0) === 0x80) { pos--; }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos &#x3c; 0) { return max; }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] &#x3e; max) ? pos : max;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 &#x26;&#x26; (_mode === c.Z_FINISH || _mode ===
c.Z_SYNC_FLUSH))) {

        if (this.options.to === &#x27;string&#x27;) {

next_out_utf8 = strings.<span class="apidocCodeKeywordSpan">utf8border</span>(strm.output, strm.next_out);

tail = strm.next_out - next_out_utf8;
utf8str = strings.buf2string(strm.output, next_out_utf8);

// move tail
strm.next_out = tail;
strm.avail_out = chunkSize - tail;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pako.trees" id="apidoc.module.pako.trees">module pako.trees</a></h1>


    <h2>
        <a href="#apidoc.element.pako.trees._tr_align" id="apidoc.element.pako.trees._tr_align">
        function <span class="apidocSignatureSpan">pako.trees.</span>_tr_align
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _tr_align(s) {
  send_bits(s, STATIC_TREES &#x3c;&#x3c; 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.trees._tr_flush_block" id="apidoc.element.pako.trees._tr_flush_block">
        function <span class="apidocSignatureSpan">pako.trees.</span>_tr_flush_block
        <span class="apidocSignatureSpan">(s, buf, stored_len, last)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;<span class="apidocCodeCommentSpan">       /* input block, or NULL if too old */
</span>//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level &#x3e; 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, &#x22;\nlit data: dyn %ld, stat %ld&#x22;, s-&#x3e;opt_len,
    //        s-&#x3e;static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, &#x22;\ndist data: dyn %ld, stat %ld&#x22;, s-&#x3e;opt_len,
    //        s-&#x3e;static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) &#x3e;&#x3e;&#x3e; 3;
    static_lenb = (s.static_len + 3 + 7) &#x3e;&#x3e;&#x3e; 3;

    // Tracev((stderr, &#x22;\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u &#x22;,
    //        opt_lenb, s-&#x3e;opt_len, static_lenb, s-&#x3e;static_len, stored_len,
    //        s-&#x3e;last_lit));

    if (static_lenb &#x3c;= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, &#x22;lost buf&#x22;);
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 &#x3c;= opt_lenb) &#x26;&#x26; (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE &#x3e; WSIZE.
     * Otherwise we can&#x27;t have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE &#x3c;= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES &#x3c;&#x3c; 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES &#x3c;&#x3c; 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s-&#x3e;compressed_len == s-&#x3e;bits_sent, &#x22;bad compressed size&#x22;);
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,&#x22;\ncomprlen %lu(%lu) &#x22;, s-&#x3e;compressed_len&#x3e;&#x3e;3,
  //       s-&#x3e;compressed_len-7*last));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.trees._tr_init" id="apidoc.element.pako.trees._tr_init">
        function <span class="apidocSignatureSpan">pako.trees.</span>_tr_init
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

<span class="apidocCodeCommentSpan">  /* Initialize the first block of the first file: */
</span>  init_block(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.trees._tr_stored_block" id="apidoc.element.pako.trees._tr_stored_block">
        function <span class="apidocSignatureSpan">pako.trees.</span>_tr_stored_block
        <span class="apidocSignatureSpan">(s, buf, stored_len, last)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;<span class="apidocCodeCommentSpan">       /* input block */
</span>//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK &#x3c;&#x3c; 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pako.trees._tr_tally" id="apidoc.element.pako.trees._tr_tally">
        function <span class="apidocSignatureSpan">pako.trees.</span>_tr_tally
        <span class="apidocSignatureSpan">(s, dist, lc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;<span class="apidocCodeCommentSpan">  /* distance of matched string */
</span>//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist &#x3e;&#x3e;&#x3e; 8) &#x26; 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist &#x26; 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc &#x26; 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist &#x3c; (ush)MAX_DIST(s) &#x26;&#x26;
    //       (ush)lc &#x3c;= (ush)(MAX_MATCH-MIN_MATCH) &#x26;&#x26;
    //       (ush)d_code(dist) &#x3c; (ush)D_CODES,  &#x22;_tr_tally: bad match&#x22;);

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defailts,
// don&#x27;t enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit &#x26; 0x1fff) === 0 &#x26;&#x26; s.level &#x3e; 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode &#x3c; D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length &#x3e;&#x3e;&#x3e;= 3;
//    //Tracev((stderr,&#x22;\nlast_lit %u, in %ld, out ~%ld(%ld%%) &#x22;,
//    //       s-&#x3e;last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches &#x3c; (s.last_lit&#x3e;&#x3e;1)/*int /2*/ &#x26;&#x26; out_length &#x3c; (in_length&#x3e;&#x3e;1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
